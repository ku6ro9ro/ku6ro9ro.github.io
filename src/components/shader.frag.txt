#ifdef GL_ES
precision mediump float;
#endif

#extension GL_OES_standard_derivatives : enable

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

vec2 hash22(vec2 p) { 
    float n = sin(dot(p, vec2(41, 289)));
    return fract(vec2(262144, 32768)*n); 
}

float hash12(vec2 n) { 
	return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
}

float noise12(vec2 p){
	vec2 ip = floor(p);
	vec2 u = fract(p);
	u = u*u*(3.0-2.0*u);
	
	float res = mix(
		mix(hash12(ip),hash12(ip+vec2(1.0,0.0)),u.x),
		mix(hash12(ip+vec2(0.0,1.0)),hash12(ip+vec2(1.0,1.0)),u.x),u.y);
	return res*res;
}

vec2 noise22(vec2 p){
	return vec2(noise12(p), noise12(p + 10.0));	
}

float voronoi2D(vec2 coord){
	
	float noise = 1.0;
	
	vec2 fr = fract(coord);
	vec2 fl = floor(coord);
	
	for (int i = -1; i <= 1; ++i){
		for (int j = -1; j <= 1; ++j){
			vec2 neighbour = vec2(i, j);
			
			vec2 noisecoord = noise22(hash22(fl + neighbour) * 433.0 + time) + neighbour;
			float d = distance(noisecoord, fr);
			
			noise = min(noise, d);
		}
	}
	
	return 1.0 - (noise);
}

float vFbm(vec2 coord){
	const int steps = 4;
	
	float noise = 0.0;
	float a = 0.5;
	float b = 1.0;
	
	for (int i = 0; i < steps; ++i){
		noise += voronoi2D(coord * b) * a;
		a *= 0.5;
		b *= 2.0;
	}
	
	return noise;
}

void main( void ) {

	vec2 position = gl_FragCoord.xy / resolution.xy;
	position.y *= resolution.y / resolution.x;
	position = floor(position * 250.0) / 25.0;

	vec3 color = vec3(0.0);
	color += voronoi2D(position * 10.0);

	gl_FragColor = vec4(color, 1.0 );

}